#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int palind(char *str) {
    int len = strlen(str); // длина исходной строки
    int t_len = 2 * len + 3; // длина новой строки T
    char *T = malloc(t_len); // новая строка для алгоритма, выделяем память
    T[0] = '$'; // начало строки
    T[t_len - 1] = '@'; // конец строки
    for (int i = 0; i < len; i++) {
        // вставляем # между символами исходной строки
        T[2 * i + 1] = '#'; // 2*i+1 - на нечетн.позиции
        
        T[2 * i + 2] = tolower(str[i]); // 2*i+2 - на четн.позиции
    }                 // понижаем регистр
    T[2 * len + 1] = '#'; // вид : $#a#b#c-"#"-@
    T[t_len] = '\0';
    int *P = malloc(t_len * sizeof(int)); // массив P будет хранить длины палиндромов с центрами в соответствующих позициях преобразованной строки T
    for (int i = 0; i < t_len; i++) P[i] = 0; // по алгоритму изначально как будто нет палиндромов, потом P[i] будет увеличиваться как только будут найдены палиндромы
    int C = 0, R = 0;
    // C - индекс центра текущего самого правого палиндрома, R - индекс правой границы этого палиндрома
    // C=0, R=0 значит что изначально палиндромов нет, алгоритм начнёт поиск с первого символа
    for (int i = 1; i < t_len - 1; i++) { // i(текущий центр, для которого ищем палиндром), границы исключают спецсимволы
        int mirror = 2 * C - i; // mirror — индекс, симметричный i относительно центра C
        if (i < R) P[i] = (R - i < P[mirror]) ? R - i : P[mirror];
        while (T[i + P[i] + 1] == T[i - P[i] - 1]) P[i]++; // пока символы справа и слева совпадают P[i] увел.
        if (i + P[i] > R) { // если центр i не в границе R, обновляем границы и делаем сдвиг правой границы
            C = i;
            R = i + P[i];
        }
    }

    int is_palindrome = 0;
    for (int i = 1; i < t_len - 1; i++) {
        if (P[i] >= len) { // if радиус палиндрома с центром в i больше или равен длине исходной строки - строка палиндром
            is_palindrome = 1;
            break;
        }
    }

    free(T); // освобождаем память выделенную под преобразованную строку T
    free(P); // освобождаем память выделенную под массив длин палиндромов P
    return is_palindrome; // 1-палиндром, 0- не палиндром
}
int main() {
    FILE *file = fopen("w.txt", "r");
    if (file == NULL) {
        printf("Ошибка открытия файла!\n");
        return 1;
    }

    char line[1000];
    while (fgets(line, sizeof(line), file)) {
        line[strcspn(line, "\n")] = '\0';
        printf("Строка: %s\n", line);
        if (palind(line)) {
            printf("Это палиндром (по алгоритму Манакера)!\n");
        } else {
            printf("Это НЕ палиндром!\n");
        }
    }

    fclose(file);
    return 0;
}